JSP
	• java server pages -> a html-t fogalmazhatjuk meg benne és írhatunk bele java kódot is.
	• A formról a servletnek beküldött adatokat a request.getParameter() - el tudjuk kiszedni (olyan mint php-ben a $_GET[])
	• Javaból érkező attribute kiolvasása expression language használatával: ${name}
	• Az expression language segítségével tudunk dinamikus adatot tenni a html-be a jsp file-okban.
	• A jsp file is a servlet része, amit a servletben megírunk itt is meg tudnánk, úgy ahogy a servletben is lehetne html-t írni. De pont azért van a jsp, hogy elkülönüljön a frontend és a backend.
  • A jsp-ben ha java kódot akarunk írni <% %> jelek közé kell tenni. Érték használata később a html részben <%= %>. Java osztály import: <%@ page import="java.util.Date"%>

Szerver ismeretek:
  Maven:
  	• A pom.xml-ben lévő dependency-k alapján letölti automatikusan a szüksége .jar file-okat a project-hez.
  	• A maven csinál egy local repository-t a saját gépen .m2/repository néven, és ide tölti le a .jar fileokat a távoli repobol, ami a Central Repository.
  	• A saját brojektünket buildeli automatikusan. A build több lépésből áll, amit a maven megcsinál magától egymás után. Ezt hívjuk Build LifeCycle-nek
  	Lépései:
  		Validate
  		Compile
  		Test
  		Package
  		Integration Test
  		Verify
  		Install
  		Deploy
  	A buildet az mvn clean install paranccsal tudjuk elindítani. (A clean először töröl mindent a targe folder-ből)
  Létrehozás:
  	Maven Project
  		· maven-archetype-quickstart
  		· gruop_id, artifact_id, package name kitöltése
  Előnye:
  	• Ha nem akarjuk a spring keretrendszert használni, ez ugyanúgy használja a pom.xml-t és kezeli a dependency-ket.
    • Ha sima java projektet hoznánk létre, ott a külső csomagokat manuálisan kell behúznunk.

  Státuszkódok:
  	Headerben ékeznek a response-ban (válaszban)
  		1xx - informatív leírás
  		2xx - minden rendben
  			200 - a kérés értelmezve lett és a ráadott válasz is ok
  			204 - minden ok a kéréssel, de nem kell visszaadni választ
  		3xx - át leszünk irányítva valahová
  			301 - a tartalom új címre költözött és átirányítás történik
  			307 - ideiglenes átirányítás (nem végleges az új cím)
  		4xx - kliens oldali hiba
  			400 - hibás lekérdezés
  			401 - nincs jogosultság a válasz megtekintésére, ilyenkor ált. autentikációra van szükség.
  			403 - tiltott elérés (akár autentikál akár nem a felhasználó), nem engedélyezett számára a válasz elérése
  			404 - nem található
  		5xx - szerver oldali hiba
  			500 - belső szerver hiba, nem kapunk választ
  			503 - a szolgáltatás nem elérhető

  Methodok:
  	• GET
  		○ paramétereket url-ben adjuk át, látható, elmenthető könyvjelzőként, limitált mennyi paraméter lehet.
  		○ ezt használjuk adatbázisból kikérdezéshez (pl. select)
  	• POST
  		○ nincs limit a paraméterekben, akár fájlokat is küldhetünk, könyvjelzőként nem menthető, valamivel biztonságosabb.
  		○ A paramétereket a body-ban adjuk át általában json formátumban
  		○ Ezt használjuk INSERT/UPDATE művelet esetén (adatbázisba írás)
  	• PUT
  	• DELETE
    • CONNECT stb.

  Adatáramlás:
    	• Amikor első alkalommal ütünk be egy oldalt, hosszabb idő amíg elérjük.
    	• Másodszorra már le van tárolva a gépen, hogy ahhoz a domain-hez milyen IP tartozik és már automatikusan ezzel indítjuk el a kérést.
    	• Az adat közel fénysebességgel halad az optikai kábelekben.
    	• A kommunikáció mindig egy request-response (kérés-válasz) párosból áll:
    		Request és Response:
    			§   A request és response is két részből áll:
    				header - alap adatok
    					® http státuszkód
    					® mime type ami a response headerjében info, hogy mit ad vissza a szerver, ez segít a böngészőnek, pl ha pdf-et kap vissza meg tudjuk nyitni a böngészőben pdf-ként ---> ehhez tudnia kell mit kap (típus)
    						MIME type:
    							} text/html
    							} audio/mp3
    							} image/jpeg
    				body - ami magát az adatot tartalmazza. (pl html+css+js, mp3 stb.) A böngésző ebből tudja összeállítani az oldalt. Ma már jobban terhelhetőek a böngészők mint régebben voltak, mert a felhasználók gépe nagyobb teljesítményű, így a szerver helyett sok mindent át lehet adni a böngészőnek (régen szinte mindent a szerver végzett). A böngésző tudja futtatni a javascriptet.
    				Vannak olyan szerverek, amelyek egyáltalán nem adnak vissza html-t, mert pl vannak mobilalkalmazások amelyek webesek és html-t használnak, de vannak a native mobilalkalmazások. Ezek az Iphone/Android grafikus elemeit használják és a szervertől csak adatokat kérnek le. A válasz egyszerű xml vagy json lesz.
    					® webszerver - html alapú választ ad (weblaphoz)
    					® soap/rest szerver - xml/json/yaml választ ad (natív mobilalkalmazáshoz, vagy ahol külön van a frontend pl angularban, a backend pedig csak adatot ad)
    			§ Request: a kérés, benne az IP címemel, a kérésben vannak adatok, a routerem IP címe például, hogy hová kell majd visszaadni az adatot.
    			§ Response: a válasz, amely apró adatcsomagokból áll. Ez a routerhez érkezik meg, és a router tudja, hogy a hálózatban melyik géphez kell az üzenetet eljuttatni. Az adatok részletekben érkeznek meg a szerverről. Két féle csatornán történhet ez meg: UDP és TCP
    					® UDP - skype, sportközvetítés, ahol az adatáramlásban nincs ellenőrzés, néha kimaradhat egy-egy részlet, az a fontos, hogy menjen
    					® TCP - lassabb a kommunikáció, mert folyamatos rákérdezés van az adatcsomagokra, hogy rendben megérkeztek-e. A szerver újraküldi ami nem érkezett meg.

  Fogalmak:
    Programok elérhetősége:
    	• Ha mindenki számára elérhetővé szeretnénk tenni a programunkat, a böngészőben mutatjuk meg és tesszük közzé és használhatóvá.  A böngésző, vagy egy mobilapp a kapu a felhasználó felé. A háttérben ugyanaz a program fut, ami a logikát adja. Manapság ez az elterjedtebb az asztali alkalmazással szemben. Böngészős alkalmazás is tud úgy működni, hogy például csak egy céges helyi hálózaton elérhető és nincs port nyitva a szerveren a külső eléréshez.
    	• Az alkalmazást és a hozzá kapcsolódó adatbázisnak is kell egy szerver környezet. Tehetjük egy szerverre az alkalmazást és az adatbázist, de külön szerveren is lehetnek.  Vannak szerver környezeteket szolgáltató cégek, ahol pár kattintással alakíthatunk ki egy szerver környezetet. Ilyen pl a Heroku. Ennek van ingyenes verziója is.
    	• Ha csak bizonyos körön belül szeretnénk elérhetővé tenni az alkalmazást, például egy cégen belül, akkor az asztali alkalmazás is jó választás lehet.
    IP változatok:
    	A lakossági felhasználónak folyamatosan változó IP címük van általában, a fix jóval drágább. De ez elég is az internetezéshez, mert a másik oldalon lévő fix IP-t elég tudnunk erről az oldalról. Dinamikus ip-hez is lehet domain-t regisztrálni csak jóval bonyolultabb.
    Domain név:
    	 Szerver ip címéhez van hozzárendelve, hogy ne az IP címet kelljen beütni a böngészőbe. Ezek fix IP címek.
    Szerver (Kiszolgáló):
    	A háttérben futó program/logika, ide jutunk a böngészőn, appon (egyszóval: nézet) keresztül.  Adattárolás, kalkuláció, hozzáférés stb a feladata. A servernek van egy IP címe, amin keresztül elérhetjük és van egy domain neve is, ezt szoktuk beírni a böngésző címsorába, de ha tudjuk az IP címet és azt írjuk be is ugyanoda vezet. Példa cmd -> ping vmilyen webcím (adatcsomagokat küld, így kipróbálható, hogy tényleg létezik-e a webcím és az IP-t is megkapjuk.)
    F12:
    	 Böngésző fejlesztői segédje
    Cachelés:
    	Bizonyos dolgokat pl képet egy oldalról elment a böngésző, és legközelebb innen tölti be --> gyorsabb lesz, viszont ha frissítik az oldalt új képpel stb, az nem fog befrissülni. --> Fontos, hogy mit engedünk cachel-ni és mit nem. Inkognitó módban nem cachel a böngésző. A számítógépen nem hagy nyomot ez a módszer. De pl ha egy munkahelyen monitorozzák a böngészést ott lászódni fog a meglátogatott weboldal.
    Postman:
    	 Szimulálni tudjuk egy szervernek küldött kérést, és látjuk a rá érkezett választ.
    	 Authorization fül alatt tudjuk kiválasztani milyen típusú autentikációt akarunk tesztelni.
    Authentikáció:
    	A felhasználó igazolja, hogy rendelkezik az eléréshez szükséges jogokkal, ezt megteheti pl egy username+password párossal. Ha ez nem sikeres egy http kóddal jelezhetjük, hogy megtagadjuk a válasz adását (pl. 401).
    Basic (access) authentication:
    	A request headerjében tudjuk vizsgálni az autentikációt. Ha van, és küldött a felhasználó username + password párost itt tárolódik, innen tudjuk kiolvasni. De a header a username+password párost kódolva tartalmazza. (Base64 eljárással --> bináris adatot csinál). A szerver ezt vissza tudja fejteni. Ugyanabból a szóból mindig ugyanaz a kód lesz, feltörhető, de valamivel biztonságosabb, mint szimplán küldeni. Viszont ez nem elég ezért fontos hogy a kapcsolat https (-ssl/tls) kapcsolat legyen. Ez biztonságos kapcsolat. SSL vagy TLS segítségével titkosítva van az adat.
    Socket:
    	Objektum, amit a java program használ, hogy kommunikálni tudjon távoli eszközzel. Küld valamit az én gépemen futó java program ennek segítségével, amit egy másik gép java programja fogadni tud. Ehhez az kell, hogy mindkét gépen telepítve legyen az adott program.
    Servlet:
    	Java objektum, amely tud http kérést feldolgozni és tud is rá válaszolni, bele van programozva.
    	A servlet mindig egyszer van létrehozva és minden felhasználó ugyanazt a példányt fogja visszakapni.
    	Főbb metódusok (ezeket overideoljuk):
    		○ DoGet
    		○ DoPost
    		○ GetServletInfo – van visszatérési értéke, bármilyen infot beírhatunk amit ki akarunk íratni
    		○ Init - ez akkor fut le amikor a tomcat létrehozza az adott servletet, minden más előtt tehát - ezért itt csinálhatjuk pl az adatbázis kapcsolatot, kiolvashatunk konfigurációs fájlból adatokat stb.
    		○ Destroy - amikor a servlet elpusztul akkor fut le, kapcsolatok lezárása, pl. adatbázisé. Fontos, hogy minden olyan kapcsolatot lezárjunk amire van lehetőség. Az adatbázis kapcsolatnak timeout-ot is lehet beállítani, amikor automatikusan bontja a kapcsolatot.
    Singleton:
    	Egy példány él belőle a JVM-ben és mindenki ugyanarra az egy objektumra hivatkozik, az osztályváltozók értéke ugyanaz lesz, nem kell külön static-re állítani.
    	A servlet is így viselkedik, de nem minden esetben, ezért nem mondjuk rá, hogy singleton. Vannak speciális esetei.
    Konfiguráció:
    	Xml alapú: web.xml-ben regisztráljuk a servleteket és az útvonalat
    	Annotáció alapú: Pl.: @WebServlet(name = "feldolgozas", urlPatterns = {"/feldolgozas/*"})

  Szerverek közötti kommunikáció
    	• Szerverek közötti kommunikáció, adatáramlás lehetősége (mindegy milyen nyelven vannak írva): xml, json, yaml
    	• A szerverek a megkapott xml, json adatot egy parser segítségével tudják kibontani a saját nyelvüknek megfelelően és állítják össze belőle az objektumot.
    	• Az xml és json minden nyelvben ugyanúgy fog kinézni.
    	• Xml - JSON konverterrel megnézhetjük egy adott adatot amit küldeni akarunk mindkét formában.
    	• JSON validátorral pedig ellenőrizhetjük, hogy helyes-e a formátuma (szerkezete).
    xml - olvashatóbb
    json - kevesebb karater, képes különbséget tenni, hogy egy számot számként vagy szövegként küldök
    yaml - még kevesebb karakter, kapcsos zárójelek nélkül

  Tomcat
    Fogalma:
    	• Egy keretrendszer amin képes futni a spring.
    	• Tomcat-et önmagában is tölthetünk le, de a xampp-ban is benne van.
    Részei:
    	• Catalina (itt fut a kód, benne a servlet)
    	• Coyote (a kapu, fogadja a kéréseket és küldi az adatot, közvetít a Catalina felé)
    Beállítása:
    	• conf mappa, server.xml -> connector: itt lehet megadni a localhost port számát, amin keresztül elérjük a böngészőt.
    	• conf mappa, tomcat-users.xml -> itt tudjuk megadni a jogosultságokat
    		<role rolename="manager-gui"/>
    		<role rolename="manager-script"/>
    		<role rolename="manager-jmx"/>
    		<role rolename="manager-status"/>
    		<role rolename="admin-gui"/>
    		<role rolename="admin-script"/>
    		<user username="admin" password="admin" roles="manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script"/>
    Környezeti változók:
    	A működéshez környezeti változóna be kell állítani:
    		Rendszerváltozók alá:
    			▪ JAVA_HOME: C:\Program Files\Java\jdk1.8.0_144
    			▪ JRE_HOME: C:\Program Files\Java\jre1.8.0_231
    			▪ CATALINA_HOME: C:\Program Files\Java\xamppJavaTomcat\tomcat
    		Saját változók:
    			▪ Path: C:\Program Files\Java\jdk1.8.0_144\bin;C:\Program Files\Java\jre1.8.0_231\bin
    Indítás:
    	• cmd -> tartalmazó mappa(tomcat/bin) -> startup.bat
    	• Ha localhost:8080 esetleg 500-as hibát ad, akkor a tomcat mappán kell megnézni a mappa jogosultságokat

  Server oldali alkalmazás írása keretrendszer nélkül:
    	Tomcat telepítése
    	JRE telepítése
    	Kötelező felépítése:
    		○ A tomcat-ben van egy webapps mappa, ami a webalkalmazások mappája, ebbe hozzuk létre a saját alkalmazásunk mappáját (ez lesz a servletünk).
    		○ A webapps mappában vannak már servletek, ezeket látjuk megjelenni a tomcat oldalaként amikor elindítjuk a localhost:8080-at.
    		○ Ami a web- és meta-inf mappákban van az nem elérhető a felhasználók számára
    		○ Ami kívül a projektben az igen (html, css, jsp, kép).
    		○ Az src és classes mappa egymás tükörképei kell legyenek.
    		○ A compiler fordítja le a .java-t .class-ra.
    		WEB-INF
    			▪ src (kódot tárolja .java)
    			▪ package mappák (egyezik a fájlban a package nevével)
    			▪ .java fájlok (egyezik az osztály nevével)
    			▪ lib (függőségek/dependency pl.:itext)
    			▪ classes (lefordult kód .class) --> ebből lesz a jar fajl
    			▪ Web.xml (servletek elnevezése, gyűjteménye): deployment descriptor (DD), útvonalak --> mit ír be a felhasználó és milyen servletet ér el ezzel
    			▪ Konfigurációs fájl: Ebben szokták megadni például az adatbázis kapcsolódáshoz szükséges adatokat stb. Így ha valami változik csak itt kell módosítani. WEB-INF-en belül hozzuk létre, a web.xml mellé. Másik módszer hogy környezeti változóval adjuk meg az útvonalát, bárhol is legyen a szerveren a fájl így be tudom húzni (ez a biztonságosabb)
    		META-INF
    	Alkalmazás lefordítása:
    		.java -> .class
    		cmd --> web-inf mappa --> javac -d (destination, hová) classes src\test\teszt.java (forrás)
    	Külső fájlok:
    		Amiket használok importként a fájlban, az kell létezzen az alkalmazásomban. A tomcat ezeket tartalmazza, csak át kell húznom ami kell. A C:\Program Files\Java\jdk1.8.0_144/jre/lib/ext mappába kell beletenni. Ez (jre) a futtatási környezet. Ha ez rendelkezik az importként használt fájlokkal, akkor az alkalmazásunk látni fogja.
    		Ha nem tesszük át akkor cmd-ben meg kell adni a használni kívánt import fájl  jar fájljának az útvonalát:
    			javac -d classes -cp ..\..\..\lib\servlet-api.jar src\test\HelloServlet.java
    	FrontEnd:
    		A html/frontend fájlokat a WEB-INF mappán kívül hozzük létre, hogy hozzáférhető legyen és meg tudjuk jeleníteni.
    		A html-en kívül használhatjuk a JSP-t is
    		JSP:
    			▪ java server pages -> automatikusan generál egy servletet, a html-t fogalmazhatjuk meg benne és írhatunk bele java kódot is.
    			▪ Az alkalmazáson belül, de a WEB-INF mappán kívül hozzuk létre mint a sima html-t.
    		A formról a servletnek beküldött adatokat a request.getParameter() - el tudjuk kiszedni (olyan mint php-ben a $_GET[])

Linux konfigurálás:
  OP rendszer alapok:
    Egy program megírható egy számítógépre, operációs rendszer nélkül is. Régen így készültek a programok, egy számítógép egy adott programot tudott futtatni, ami az adott hardverre lett optimalizálva. Ekkor a programnak kezelnie kellett a hardvert is. Meg kellett például mondani, hogy mennyi memóriát adjunk a programnak. Az operációs rendszerek átveszik ezeket a feladatokat, a rendszermag (kernel) kezeli a hardver erőforrásait. Így ezek megjelenése óta az operációs rendszerre írjuk a programokat.
    Operációs rendszerek:
    	Windows:
    		Kezdetben csak command line-on keresztül működött, később jelent meg hozzá grafikus felület is. Mindig gyorsabb, ha nincs grafikus felület és command line-on keresztül kell kommunikálni.
    	Linux:
    		Linus Torvalds hozta létre
    		GNU licence alapján tette közzé a kódját:
    			- Nyílt forráskódú
    			- Aki fejleszt rajta, kötelezően elérhetővé kell tennie a kódját
    		Különböző disztribúciók jöttek létre
    				□ Ubuntu
    				□ Suse
    				□ Centos
    				□ Debian
    				□ Fedora
    				□ Red Hat
    			- Hasonlóak egymáshoz, de különböző modulok vannak bennük
    			- UNIX alapú rendszer
    			- Gyors
    			- Megbízható
    			- Mivel moduláris, ezért minimalizálható => csak azokat a modulokat használjuk amire tényleg szükségünk van.
    Parancsok:
    	Az op rendszerek parancsai eltérnek egymástól, de sok hasonlóság is van bennük.

  Linux alap szerkezet:
    Mappák, amik minden linux változatban általánosságban megvannak, kevés eltéréssel:
    	bin
    	dev
    	home
    	mnt
    	proc
    	run
    	srv
    	tmp
    	var
    	boot
    	etc
    	lib
    	media
    	opt - ebbe a mappába teszzük azokat a programokat, amik a server futásához nem szükségesek, opcionálisak, az alkalmazásunk futtatásához kell pl (tomcat) stb
    	root
    	sys
    	usr
    	• Linuxon nincsenek meghajtók. Fa struktúra jellemzi. A hozzá adott eszközök (pl. nyomtató is ebbe illeszkedik bele.)
    	• A bin folderben találhatóak a használható parancsok, programok
    	• A felhasználókat csoportokba lehet rendezni, és így csoportonként lehet jogokat adni

  Linux jogosultságok:
    	• Csoport szintű
    	• Felhasználó szintű
    	• MIndenkire vonatkozó
    	• Tulajdonosi jogok
    		○ egy file tulajdonosát például megadhatjuk felhasználói szinten és csoportszinten is
    	• Hozzáférési jogok
    		○ ki mit tud kezdeni az adott file-al, ez is lehet felhasználói, csoport szintú vagy mindenkire vonatkozó
    Formátuma:
    drwxr-xr-x.  root tomcat
    	• 1. karater:
    		'-' fájl
    		'd' könyvtár
    		'l' link
    	• 2-10. karater:
    		Jogosultsági szintenként jelzi az írás/olvasás/végrehajtás jogokat (read/write/execute - rwx)
    		○ felhasználó (2-3-4 karakter)
    		○ csoport (5-6-7 karakter)
    		○ mindenki (8-9-10 karakter)
    	• A jogosultságok mellett látjuk a felhasználói szintű tulajdonost és a csoport szintű tulajdonost

  Szerverek kezelése:
    Az alkalmazások futtatásához 0-24-ben bekapcsolt szerverkörnyezet kell. Így fogják tudni a felhasználók bármikor elérni.
    Ahhoz hogy elérjünk egy szervert három alkalmazás közül választhatunk:
    	Cygwin
    		○  https://www.cygwin.com/
    	PuTTY
    		○ https://www.digitalocean.com/docs/droplets/how-to/connect-with-ssh/putty/
    		○ https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html
    	GitBash
    Ezek segítségével ssh-n keresztül tudunk bejelentkezni a saját szerverünkre. Az ssh (Secure Shell - protokoll) biztonságos kapcsolatot tesz lehetővé a saját gépünk és egy távoli szerver között.
    Command line:
    ssh root@IP cím (Mindig root felhasználóval jelentkezzünk be, mert annak van admin joga)
    droplet password

  DigitalOcean:
    Linux szerverkörnyezet létrehozása:
    	• Linuxos gép
    	• Windows-os gép esetén csinálhatunk egy virtuális gépet amin linux fut (VirtualBox)
    	• Bérlünk valamilyen szolgáltatótól
    		Webcím:  https://www.digitalocean.com/
    			○ A regisztráció ingyenes, a szerver bérlése viszont pénzbe kerül. Ha kikapcsoljuk a szervert kevesebbet számláz (fenntartási költség). Ha teljesen töröljük, akkor nem számláznak.
    			○ Dropleteket lehet létrehozni, ami egy felhőben lévő hatalmas erőforrásból egy szelet, amit rendelkezésünkre bocsát a szolgáltató. Különböző operációs rendszerek választhatók. A CentOS-al dolgozunk.
    			○ El kell neveznünk a dropletet a hostname mezőnél, bármilyen nevet adhatunk.
    			○ Ha minden kész és be van kapcsolva, tudjuk ellenőrizni, hogy elérjük-e a ping IP cím paranccsal konzolból.
    Droplet elérése:
    	Access -> Launch Reovery Console
    		Elindul egy virtuális terminál, ahol kérni fog egy jelszót, amit emailben megkaptunk vagy beállítottunk, amikor létrehoztuk a dropletet.
    		A megjenenő consolban:
    			login: root
    			password: a droplet jelszava
    			https://www.digitalocean.com/docs/droplets/resources/console/

  Linux parancsok:
    A parancsok gyakorlatilag apró programok, amiknek sok esetben adhatunk paramétereket is.
    https://explainshell.com/

  Yum:
    	• A linux program alkalmazás letöltője.
    	• Mivel konzolon keresztül csatlakozunk a távoli szerverünkhöz, ezért itt nincs böngésző, ahonnan le tudnánk a különböző alkalmazásokat szedni, ezért van szükség erre a programra. Gyorsabb is mintha böngészőn keresztül telepítenénk.
    	• Ezzel tudjuk például a JVM-et is letölteni.
    	• Használat előtt mindig frissíteni kell ezt a programot a yum upgrade paranccsal
    Csomag telepítése:
    	parancs: yum install <csomga neve> <esetleg verziószám, ha nem a legfrisebbet akarjuk> -y
    	működés: a központi repositoryjában rákeres a csomag névre és letölti, ha megtalálta.
    Csomagra keresés
    	felhasználás: ha nagyon sok változat/verzió van valamihez, így tudjuk kilistázni
    	parancs: yum serach <csomag neve>
    JDK telepítése:
    	Kétféle telepíthető: A különbség a licence-ben van, illetve vannak olyan modulok, amelyek nem találhatóak meg az openben, de az oracle-ben igen. Mindkettő egyébként az oracle-hoz tartozik.
    		○ open JDK
    		○ oracle JDK
    	Rákeresünk a java kulcsszóra és a listából minen olyat szeretnénk letölteni, ami java 1.8.0 openjdk-val kezdődik
    	parancs: yum install java-1.8.0-openjdk* -y
    Git telepítése:
    	parancs: yum install git -y

  Vi:
    	• Linuxon a vi segítségével lehet szerkeszteni a fájlokat
    	• vi <file neve> (ez létre is hozza a fájlt, ha még nem létezik)
    	• i betű lenyomásával kerülünk insert módba
    	• esc lenyomásával mentek
    	• shift z z  kombinációval lehet kilépni a szerkesztőből
    	• #!<útvona> első sorban így adom meg melyik program kell a lefuttatáshoz, ha pl bash-t akarunk használni
    	• # komment jele, ami ez után van nem fut le
    	• ha mégsem akarom elmenteni amit csináltam az insertből kilépek az esc-el, majd alulra :q! és enter a shift z z helyett
    	• A vi-ben a sorok legyenek számozottak:
    	https://www.cyberciti.biz/faq/vi-show-line-numbers/
    		○ cd -> home könyvtár
    		○ ls -la -> rejtett fájlokat is lássuk
    		○ létrehozunk egy újat vi .vimrc néven
    		○ set number -> ennyit írunk bele
    	adott file-ban:
    		:set number -> alulra

  Grep:
    Kereső:
    	• Tudom a tartalmat, de nem tudom merre keressem
    	• grep -rin "8080" tomcat/ - meg kell mondani melyik mappában. Ha rekurziv módon keresünk akkor az almappákban is keres (-r)

  Cron:
    	• Idő alapon ütemezett feladatok.
    	• sh script futtatása például:
    		○ kelleni fog a futtatandó fájl abszolút elérési útvonala
    			§ pwd -> útvonal
    			§ + fájl neve
    		○ mikor fusson
    			§ crontab.guru
    			§ pl.: minden nap hajnali kettő: 0 2 * * *
    crontab:
    0 2 * * * sh /root/java/SFJ_tanfolyam_spring_boot_ismeretek/SpringProject/build.sh

  .JAR, MAVEN:
    Projekt a szerveren:
      	1. Létrehozunk egy könyvtárat a root mappában.
      		> mkdir java
      	2. Belépünk a java mappába
      		> cd java
      	3. Githubról feltöltjük a projektünket
      		> git clone <github link>
      	4. Futtatható jar file létrehozása
      		> mvn clean install
      		> létrehozza a target foldert, ebben lesz benne a .jar file
      	5. Program elindítása
      		> cd target
      		> java -jar <alkalmazas_neve.jar>
      		> ellenőrizzük hányas porton indult
      	6. Kipróbálás
      		> szerver ip:port amin elindult az alkalmazásunk
      Alkalmazás folyamatos futtatása:
      	• DigitalOcean konzolján keresztül elindítva
      	• Alkalmazás háttérben futtatása
      		> nohup java -jar <alkalmazas_neve.jar> &
      			§ az alkalmazás visszajelzései ne a konzolon jelenjenek meg, hanem legyenek elirányítva. Így ha kilépünk a konzolból, vagy a programból, akkor is fut tovább a háttérben
      Háttérben futó folyamatok leállítása:
      	• kilistázzuk a háttérben futó folyamatokat
      		> ps
      	• id vagy név alapján
      		> pkill java
      Automatizálás:
      	Lépései:
      		> Meghatározott időözönként történjen meg a gitben lévő legfrisebb változat lehúzása
      		> A jelenleg futó alkalmazás álljon le
      		> Maven segítségével történjen meg az újra csomagolás
      		> Futtassa az új kódot
      	Megvalósítás:
      		Shell Script írása a bash segítségével, ez egy programozási nyelv, ami közvetlenül az operációs rendszerrel kommunikál, procedurális nyelv
      			§ létrehozunk egy .sh kiterjesztésű fájl-t a projekten belül ahol a target mappa is van
      			§ a fájlt azzal kell kezdeni, hogy megmondjuk milyen nyelven íródik, milyen interpreter kell hozzá, vagyis a bin folder melyik programját használja. Nekünk a bash fog kelleni
      	Szerkezet:
      		#!<útvona> - így kell kezdődnie, és ez mindig az első sorban kell legyen, itt adjuk meg melyik programhoz irányítjuk
      		echo - konzolra ír üzeneteket
      		mv target/springproject-0.1.jar ../ - file egy könyvtárral feljebb helyezése mint amiben a .sh van
      		mv target/springproject-0.1.jar ./ - file abba a mappába kerül mint a .sh
      		#!/bin/bash
      		echo Leszedem a legfrisebb kódot
      		git pull
      		#Ezzel a file-al automatizáljuk a folyamatot
      		echo Kezdem a buildelést
      		mvn clean install
      		mv target/springproject-0.1.jar ../
      		echo Készen van a buildelés
      		echo Leállítom a jelenleg futó java alkalmazást
      		pkill java
      		echo indítom a legfrisebb verziót
      		nohup java -jar springproject-0.1.jar &
    Port váltás:
      	Portok:
      		A tomcat alap esetben a 8080-on indul el
      	.jar
      		Megadhatjuk az src/main/resources/application.properties-en, hogy milyen porton fusson az alkalmazásunk
      		server.port = 80
      		hátránya: minden módosításkor be kell jönni a projektbe, módosítani kell és újra kell buildelni mindig
      		megoldás: az application.properties-t projekten kívülre tudjuk másolni, így itt is lesz egy példány, és ebben tudom elvégezni a módosításokat, a .jar file mellé kerüljön. Ha valami miatt ez a külső más fájlban van, akkor az alkalmazás indításakor át kell adni paraméterben, hogy honnan húzza be:
      		java -jar springproject-0.1.jar -Dspring.config.location=<utvonal>/application.properties
      		Ez lesz az elsődleges property, ez után nézi azt ami a projektben van. A projektben lévő fájlokat csak és kizárólag giten keresztül lehet módosítani, csak így nem nyúlunk bele.
      		kód: cp src/main/resources/application.properties ./(éppen aktuális mappát jelenti)
      	.war
      		A tomcat portját át lehet állítani, de a linuxon az 1024 alatti portok védve vannak, ezért kerülő megoldást lehet használni:
      			§ A 80-as portra érkező kéréseket átírányítjuk a 8080-ra
      				iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination :8080
      			§ /etc/systemd/system/tomcat.service fájlban módosítunk:
      				□ ebben megadjuk az application.properties helyét, amiben benne van a port módosítása:
      					-Dspring.config.location=<utvonal>/application.properties
      				□ lehet egy szerveren több alkalmazás is, ilyenkor webapps mappán belül különböző .war file-ként élnek, ebben az esetben minden alkalmazás megkapja a beállított application.properties-t, ezért ez ilyen esetben nem jó megoldás
      			§ /tomcat/conf/catalina.properties
      				□ ez is csak akkor jó megoldás, ha csak egy alkalmazásunk van a szerveren
      				□ a file-ban a common.loaderhez abszolút útvonallal megadva felfűzzük a saját application.properties file-unkat
      					common.loader="${catalina.base}/lib","${catalina.base}/lib/*.jar","${catalina.home}/lib","${catalina.home}/lib/*.jar", "/opt/tomcat/conf/sajatConf/*"
      			§ Legjobb megoldás, ha több alkalmazás van akkor is jó
      				□ tomcat/conf -on belül új mappa appConf és ebbe tárolom az application.properties file-t
      				□ A tomcat-et el kell irányítani ehhez a file-hoz, és meg kell adni azt is melyik alkalmazásnál használja
      				□ tomcat/conf/Catalina/localhost mappában az alkalmazás nevével (.war neve) létre kell hozni egy file-t
      					® ROOT.xml
      					Tartalma:
      						<?xml version="1.0" encoding="UTF-8"?>
      						<Context>
      						      <Environment name="spring.config.location" value="file:/opt/tomcat/conf/appConf/" type="java.lang.string"/>
      						</Context>
      				□ mivel az xml neve megegyezik a .war nevével, ezért csak erre fog vonatozni ez a beállítás, hogy ezt az applocation.properties-t használja

  .WAR, TOMCAT:
    Tomcat telepítése:
      https://www.digitalocean.com/community/tutorials/how-to-install-apache-tomcat-8-on-centos-7
      https://tecadmin.net/install-tomcat-8-on-centos-8/
      Részletes út:
      	• A tomcat egy kapu a szerverünk és a külvilág között, ezért biztosnági kockázatot is jelent.
      	• wget telepítése a yum segítségével
      	• A Tomcat oldalán megkeressük a telepítőjét:
      	https://tomcat.apache.org/download-80.cgi
      		○ .zip -> windows-ra optimalizált
      		○ tar.gz -> linuxra ennek az útvonala kell a böngészőből (binary distributions féle)(copy link location)
      		https://downloads.apache.org/tomcat/tomcat-8/v8.5.63/bin/apache-tomcat-8.5.63.tar.gz
      	• Parancs:
      		○ wget <link> --> ezzel töltjük le a tar.gz-t
      	• Kicsomagolás:
      		○ tar xzf apache-tomcat-8.5.63.tar.gz
      	• Kitöröljük a tar.gz-t
      	• A tomcat-et nem futtatjuk root jogosultsággal, mert a root-nak admin joga van, így ha valami biztonsági rés van az alkalmazásunkban vagy a tomcaten, akkor könnyen visszaélhetnek vele, pl lefuttathatnak távolról valmit stb. Ezért létrehozunk egy felhasználót a tomcat futtatásához.
      		○ groupadd tomcat -> új csoport létrehozása
      		○ useradd -g tomcat -M -d /opt/tomcat -s /bin/nologin tomcat -> új felhasználó létrehozása a tomcat csoportba és a helye az a root-al azonos szintű opt mappában a tomcat almappában legyen. Tehát ha ő belép, úgy ahogy a root a rootba kerül, ő ebbe az opt/tomcat-be alapból, ide fogjuk tenni a tomcat programot is. Végül letiltjuk, hogy ezzel a felhasználóval ne lehessen egyébként bejelentkezni
      	• Áthelyezzük a kicsomagolt tomcat file-okat az opt/tomcat-be
      		○  mv apache-tomcat-8.5.63/ /opt/tomcat
      	• Beállítjuk a mappa tulajdonosnak az új tomcat csoportot, a felhasználói szintű tulajdnos marad a root
      		○ chgrp -R tomcat /opt/tomcat
      	• A tomcat/conf mappához állítunk csoportszintű olvasási jogot és végrehajtási jogot
      		○ chmod -R g+r /opt/tomcat/conf
      		○ chmod -R g+x /opt/tomcat/conf
      	• A tomcat felhasználónak tulajdonosi jogot adunk az opt/tomcat/webapps, work, temp/log mappa felett
      		○ chown -R tomcat /opt/tomcat/webapps/
      	• A tomcatet futtatható szervizként regisztráljuk azért hogy el tudjuk egyszerűen indítani és ne kelljen a bin folderébe bemenni minden egyes alkalommal
      		○ Új file létrehozása:
      			§ /etc/systemd/system/tomcat.service
      		○ Tartalma:
      			[Unit]
      Description=Tomcat 8.5
      After=network.target
      			[Service]
      Type=forking
      			User=tomcat
      Group=tomcat
      			Environment="JAVA_HOME=/usr/lib/jvm/jre"
      Environment="JAVA_OPTS=-Djava.security.egd=file:///dev/urandom"
      Environment="CATALINA_BASE=/opt/tomcat"
      Environment="CATALINA_HOME=/opt/tomcat"
      Environment="CATALINA_PID=/opt/tomcat/temp/tomcat.pid"
      Environment="CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC"
      			ExecStart=/opt/tomcat/bin/startup.sh
      ExecStop=/opt/tomcat/bin/shutdown.sh
      			[Install]
      WantedBy=multi-user.target
      		○ Security beállítások módosítása
      			https://linux.die.net/man/1/chcon
      			https://www.redhat.com/en/topics/linux/what-is-selinux
      			○ chcon -R -t bin_t /opt/tomcat/bin/
      		○ A módosítás felismeréséhez frissíteni kell
      			○ systemctl daemon-reload
      	• Tomcat indítása:
      		○ systemctl start <service>
      	• Apach kezdő oldala elindul: http://159.65.201.58:8080/
      	• Automatikusan induljon
      Rövidebb út:
      	○ Spring boot project esetén működik az is, ha a pom.xml-be felvesszük a dependenciák közé a tomcat-et
    Tomcat beállítása:
      conf/tomcat-users.xml módosítása
		    ○ különböző felhasználókat álíthatunk be különböző szerepörökkel, és ez szabályozza, hogy a tomcat felületen mit használhatunk. Ez egy webalkalmazás, amit a tomcat hozott létre, hogy egyszerűbben lehessen dolgokat beállítani
		    http://159.65.201.58:8080/
		  opt/tomcat/webapps
		    ○ ebben van a tomcat felülethez tartozó mappák
		    ○ ha mindent kitörlünk ebből a ROOT kivételével és a saját .war file-unkat pedig átnevezzük ROOT.war-ra, akor ha beírjuk az eredeti útvonalat:
		    http://159.65.201.58:8080/, már nem a manager felület jelenik meg, hanem az alkalmazásunk
    .war létrehozása:
      	1. Módosítani kell a pom.xml-en, a packaging-et:
      		        <groupId>com.springproject</groupId>
      		        <artifactId>springproject</artifactId>
      		        <version>0.1</version>
      		        <name>SpringProject</name>
      		        <description>Demo project for Spring Boot</description>
      		        <packaging>war</packaging>
      	2. Hozzá kell adni egy új dependency-t:
      			    <dependency>
      			        <groupId>org.springframework.boot</groupId>
      			        <artifactId>spring-boot-starter-tomcat</artifactId>
      			        <scope>provided</scope>
      			    </dependency>
      	3. Projekten belül src/main/java/com/projektünk (Itt azért kell módosítanunk, hogy fekészítsük a programot, hogy a tomcat fogja adni az application .properties file-t)
      		Abban a file-ban módosítunk amiben a main függvény (vagyis az indítópontunk van), ki kell terjesztenünk egy osztályt
      			package com.springelso;
      			import org.springframework.boot.SpringApplication;
      			import org.springframework.boot.autoconfigure.SpringBootApplication;
      			import org.springframework.boot.builder.SpringApplicationBuilder;
      			import org.springframework.boot.context.properties.EnableConfigurationProperties;
      			import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
      			import org.springframework.context.annotation.PropertySource;
      			import org.springframework.context.annotation.PropertySources;
      			@EnableConfigurationProperties
      			@PropertySources({
      			    @PropertySource(value = "file:${appConf}", ignoreResourceNotFound = true)
      			})
      			@SpringBootApplication
      			public class SpringElsoApplication extends SpringBootServletInitializer{
      				@Override
      				protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
      				return application.sources(SpringElsoApplication.class);
      				}
      				public static void main(String[] args) {
      					SpringApplication.run(SpringElsoApplication.class, args);
      				}
      			}
      	4. mvn clean install parancs
      		-> .war file létrejön a target mappában
      	5. áthelyezzük a tomcat webapps mappájába, és átnevezzük ROOT.war névre
      		mv springelso-0.1.war /opt/tomcat/webapps/
      		mv springelso-0.1.war ROOT.war (adott mappában állva)
    Ezeket a módosításokat mindig git-ben verziókezelve csináljuk és nem szerkesztünk bele szerveren a projektbe

  Adatbázis telepítés:
     PostgreSQL
     https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-centos-8
     https://askubuntu.com/questions/915191/sudo-i-problem-sudo-bin-bash-asd-command-not-found (ha nem működne a sudo -i –u postgres parancs)
     	1.  Tehetjük az alkalmazással egy szerverre, és letilthatjuk, hogy kívülről ne lehessen elérni, így csak az alkalmazás tud kommunikálni vele.
     	2. Telepítés:
     		yum install postgresql-server postgresql-contrib
     	3. postgresql-setup –initdb
     		Egy adatbázis csoportot hoz létre. Ami a postgreSQL által lesz menedzselve. Egy vázat kapunk így.
     	4. Konfugurálás:
     		Szerver engedély beállítása, hogy egy létrehozott user + pass-al lehessen használni az adatbázist.
     		vi /var/lib/pgsql/data/pg_hba.conf
     		Itt tudjuk definiálni, hogy kik és milyen módon érhetik el az adatbázist. A fájl legalján van egy táblázat, ami ezt szabályozza.
     		A method oszlopban tudjuk felhasználó szinten szabályozni az elérést, de azt is meg lehet oldani, hogy felhasználó-jelszóval bárki beléphessen.
     		Ehhez az application.properties-be kell beírni a user és password adatokat és az adatbázis elérést és a fenti fájlban át kell írnunk a felső host-ok METHOD értékét ident-ről md5-re. Az md5 egy kódolási forma, ezzel állítjuk be, hogy jelszóval fogjuk azonosítani a felhasználót.
     	5. Elindítjuk apostgreSQL-t
     		systemctl start postgresql
     	6. Beállítjuk, hogy magától elinduljon
     		systemctl enable postgresql
     	7. Felhasználó kezelés:
     		Amikor feltelepítjük a postgresql-t létrehoz magának egy alapértelmezett felhasználót, neve a postgres
     		Az adatbázis keretrendszerben ennek a felhasználónak van admin joga, ezért át kell váltani a root-ról erre.
     			sudo -i –u postgres
     	8. Adatbázis belépés
     		Az adatbázisba belépés a psql parancsal történik, ha nem írjuk utána, hogy melyik adatbázisba szeretnénk belépni, a felhasználó nevünkkkel megegyező adatbázisba fog belépni (az alap felhasználó a postgres és hozzá alapból létrejön a postgres nevű adatbázis is amiben nem lesznek még adattáblák) De megadhatjuk hogy melyik adatbázisba lépjen be.
     	9. Adattáblák lekérdezése
     		\dt
     	10. Kilépés az adatbázisból
     		\q
     	11. Kilépés a postgres felhasználóból
     		logout – visszarak a root-ba
     	12. Új felhasználó létrehozása: (role)
     		createuser --interactive
     		Role nevének megadása: freni
     		Superuser legyen-e vagy sem (beállítjuk hogy igen)
     	13. Létre kell hozni egy adatbázist a user nevéhez
     		createdb freni
     	14. Felhasználó kezelés
     		A postgres felhasználóval és a psql parancsal be tudunk lépni az újonnan létrehozott adatbázisunkba, de egyszerűsíthetjük ezt, ha linuxon is létrehozunk egy új felhasználót.
     		adduser freni
     	15. Felhasználóhoz jelszó beállítása:
     		ALTER USER freni WITH PASSWORD '12345';

  PostgreSQL alapok:
    	• Támogatja a schema-kat, ilyen még az oracle is.
    		A schema logikai csoportosítást tesz lehetővé az adatbázison belül a táblák között. A logikailag összetartozó táblákat berendezhetjük egy schema alá
    	• A public az alap scema, ebben hozza létre az új táblákat alapból
    	• Alapértelmezett portja: 5432
    	• spring.datasource.url = jdbc:postgresql://159.65.201.58:5432/database
    	• Konzolon az sql - ek írhatóak több sorban

  Adatbázis használat:
    Tábla létrehozása:
    	CREATE TABLE firstTable;
    	(age int);
    Tábla törlése:
    	DROP TABLE firstTable;
    Összetetteb tábla:
    		CREATE TABLE playground (
    		equip_id serial PRIMARY KEY,
    		type varchar (50) NOT NULL,
    		color varchar (25) NOT NULL,
    		location varchar(25) check (location in ('north', 'south', 'west', 'east', 'northeast', 'southeast', 'southwest', 'northwest')),
    		install_date date
    		);
    	• Serial típust kell választani az id-nak, ha azt szeretnénk, hogy növekedjen automatikusan (mysql autoincrement), és a postgresql ennek a típusnak külön is létrehoz egy ún. sequence-t amiben nyomon követhetjük, hogyan növekszik az id.
    	• Check azt csinálja mint a mysql enum, csak a felsorolt értékek kerülhetnek a mezőbe.
    Adatbázis külső elérése:
    	• Engedélyezni kell a szerveren, hogy távolról el lehessen érni az adatbázist
    		○ Belépünk a /var/lib/pgsql/data mappába
    		○ Szerkesztjük a postgresql.conf file-t
    			§ listen_address sornál a localhost-ot '*'- ra cseréljük és így bárki elérheti ezt az adatbázist
    			§ megadhatnánk itt ip címeket is konkrétan
    		○ systemclt-el újraindítju a postgreqsl-t
    	• Hozzáférést is kell adni:
    		○ Belépünk a /var/lib/pgsql/data mappába
    		○ Szerkesztjük a pg_hba.conf file-t
    			§ ha valaki IPV4-en szeretne kapcsolódni, azt ne korlátozzuk le semmilyen ip-re
    				□ a 127.0.0.0/32 (localhost) cseréje 0.0.0.0/0-ra
    	• A spring boot projektben meg kell adni
    		spring.datasource.url = jdbc:postgresql://159.65.201.58:5432/freni
    		spring.datasource.username=freni
    		spring.datasource.password=12345



















